# -*- coding: utf-8 -*-
"""New-10-Save and Load Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fGx8zfobgyeJoHWpYWLH1_3uDD4Gfz-k

**SAVE AND LOAD MODELS**
"""

# install dan import tf dan dependensi
!pip install pyyaml h5py

import os
import tensorflow as tf
from tensorflow import keras

print(tf.version.VERSION)

# import dataset
(train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.mnist.load_data()

train_labels = train_labels[:1000]
test_labels = test_labels[:1000]

train_images = train_images[:1000].reshape(-1,28*28)/255.0
test_images = test_images[:1000].reshape(-1,28*28)/255.0

# membuat model
def create_model():
  model = tf.keras.Sequential([
        keras.layers.Dense(512, activation='relu', input_shape=(784,)),
        keras.layers.Dropout(0.2),
        keras.layers.Dense(10)
  ])
  model.compile(optimizer='adam',
                loss=tf.losses.SparseCategoricalCrossentropy(from_logits=True),
                metrics=[tf.metrics.SparseCategoricalAccuracy()])
  return model

# membuat basic model instance
model = create_model()

# menampilkan arsitektur model
model.summary()

# Menyimpan Checkpoints selama Pelatihan

# penggunaan checkpoint callback
checkpoint_path = 'training_1/cp/ckpt'
checkpoint_dir = os.path.dirname(checkpoint_path)

# membuat callback yang menyimpan model's weights
cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_path,
                                                 save_weights_only=True,
                                                 verbose=1)

# melatih model dengan callback yang baru
model.fit(train_images,
          train_labels,
          epochs=10,
          validation_data=(test_images, test_labels),
          callbacks=[cp_callback]) # pass callback ke training

# proses ini mungkin memunculkan warning yg berkaitan dengan penyimpanan state dari optimizer
# warnings ini dapat dihiraukan

os.listdir(checkpoint_dir)

# Sekarang, bangun kembali model yang fresh dan untrained dan evaluate di test set

# membuat basic model instance
model = create_model()

#evaluasi model
loss, acc = model.evaluate(test_images, test_labels, verbose=2)
print('Untrained model, accuracy: {:5.2f}%'.format(100*acc))

# Load the weights
model.load_weights(checkpoint_path)

# re-evaluasi model
loss, acc = model.evaluate(test_images, test_labels, verbose=2)
print('Restored model, accuracy: {:5.2f}%'.format(100*acc))

# Opsi callback checkpoint

# masukkan epoch ke dalam file name (gunakan 'str.format')
checkpoint_path = 'training_2/cp-{epoch:04d}.ckpt'
checkpoint_dir = os.path.dirname(checkpoint_path)

batch_size = 32

# membuat callback yang menyimpan model's weights setiap 5 epoch
cp_callback = tf.keras.callbacks.ModelCheckpoint(
    filepath=checkpoint_path,
    verbose=1,
    save_weights_only=True,
    save_freq=5*batch_size
)
# membuat model instance baru
model = create_model()

# menyimpan weights menggunakan format 'checkpoint_path'
model.save_weights(checkpoint_path.format(epoch=0))

# melatih model dengan callback yang baru
model.fit(train_images,
          train_labels,
          epochs=50,
          batch_size=batch_size,
          callbacks=[cp_callback],
          validation_data=(test_images, test_labels),
          verbose=0)

os.listdir(checkpoint_dir)

latest = tf.train.latest_checkpoint(checkpoint_dir)
latest

# Reset model dan load latest checkpoint
model = create_model()

# muat weights yang telah disimpan sebelumnya
model.load_weights(latest)

# reevaluate model
loss, acc = model.evaluate(test_images, test_labels, verbose=2)
print('Restored model, akurasi: {:5.2f}%'.format(100*acc))

"""Kode diatas menyimpan the weights ke dalam koleksi file berformat-checkpoint yang mengandung hanya trained weights dalam format binary. Checkpoint mengandung:


*   Satu atau lebih shards yang mengandung model weights 
*   Sebuah indeks yang mengindikasikan bobot mana yang disimpan dalam salah satu shard


"""

# Menyimpan BObot Manual

# menyimpan bobot
model.save_weights('checkpoints/my_checkpoint')

# membuat model instan baru
model = create_model()

# mengembalikan bobot
model.load_weights('./checkpoints/my_checkpoint')

# evaluasi model
loss,acc = model.evaluate(test_images, test_labels, verbose=2)
print('Restored model, akurasi: {:5.2f}%'.format(100*acc))

# Menyimpan Seluruh MOdel

# SavedModel format

# membuat dan melatih model instan
model = create_model()
model.fit(train_images, train_labels, epochs=5)

# save seluruh model sebagai SavedModel
!mkdir -p saved_model
model.save('saved_model/my_model')

# Commented out IPython magic to ensure Python compatibility.
# my_model directory
# %ls saved_model

# mengandung folder assets, saved_model.pb dan variables
# %ls saved_model/my_model

# reload model Keras baru dari model tersimpan
new_model = tf.keras.models.load_model('saved_model/my_model')

# mengecek arsitekturnya
new_model.summary()

# Mengevaluasi restored model
loss, acc = new_model.evaluate(test_images, test_labels, verbose=2)
print('Restored model, akurasi: {:5.2f}%'.format(100*acc))

print(new_model.predict(test_images).shape)

# Save format menggunakan HDF5 standard

# membuat dan melatih model instan
model = create_model()
model.fit(train_images, train_labels, epochs=5)

# menyimpan seluruh model dalam file HDF5 (memperlihatkan ekstensi '.h5')
model.save('my_model.h5')

# membuat file dari file diatas

# membuat ulang model yg sama, termasuk bobot dan optimizer nya
new_model = tf.keras.models.load_model('my_model.h5')

# tampilkan arsitektur model
new_model.summary()

# mengecek akurasi
loss,acc = new_model.evaluate(test_images, test_labels, verbose=2)
print('Restored model, akurasi: {:5.2f}%'.format(100*acc))

"""Keras saves models by inspecting their architectures. This technique saves everything:

1. The weight values
2. The model's architecture
3. The model's training configuration (what you pass to the .compile() method)
4. The optimizer and its state, if any (this enables you to restart training where you left off)



"""